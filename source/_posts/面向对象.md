

面向对象是一种编程思路，不会改变预期效果
优点：使用面向对象，会提高代码的复用性，便于迭代

###### []()创建

1.字面量
`let obj={ }`
2.构造函数

>`let obj = new Object()`
>函数名的首字母大写，一次来和普通的函数区分
>new运算符，也叫构造器，配合使用的函数，被称为构造函数
>作用：1.执行该函数
>   2.隐式创建一个对象
>   3.把该对象和函数的this指向互相绑定
>   4.可以把this中的属性和方法都加到该对象上
>   5.函数执行后，返回该对象
>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206173226207.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206173226671.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

3.工厂模式

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206172519615.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206172527295.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

###### []()使用

1.通过点语法
2.通过中括号

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206171634920.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206171632706.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

#### []()原型

每次通过构造函数去去实例化对象，都会生成一个新的内存空间
当项目开发中，往往大量的内存使用，会严重影响性能
原型： 将公有的方法，放到原型中，每次实例化对象，原型中的内容是公有的，不会再分配新的空间给对象(构造函数中的属性/方法 会)
原型中的方法，地址相同，是一个公有的内存
构造函数中的方法，地址不相同。 两个独立的内存

#### []()继承

通过某一种方式让一个对象，可以访问并使用到另一个对象中的内容，这种行为我们叫做继承
作用：节省了各个构造函数中，大量重复的属性和方法，提高了开发效率，并节省了内存

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206180327679.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206180348754.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

**构造函数继承**
继承的方法：call与apply方法的使用，达成了构造函数继承的作用
区别：call接受参数时，数量根据被借用者需要的参数而
   apply只有两个参数，借用者与数组(存放所有参数)
**call 对象冒充，又叫对象借用**
语法：`被借用者.call(借用者,被借用的参数)`

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206181326514.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206181335843.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

`apply()` 方法与call相同，都用于借用对象
语法：`被借用者.apply(借用者,[被借用者的参数])`

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206181919136.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206181939769.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

**原型链继承**
将父类的实例化对象赋值给子类的原型
语法：`子类的构造函数名.constructor=父类的实例化对象`
优点：类似于赋值了一个对象，构造函数和原型中所有的数据都可以获取到，简约方便使用
缺点：1.原型链继承自身无法传参
   2.父类所有的属性和方法都可以被所有子类共享

**组合继承**
类式继承，无法获取父类的原型链
原型链继承，无法直接给父类传参
组合继承=类式继承+原型链继承
结合优点，弥补缺点

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206184039630.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206184050886.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

#### []()传值和传址

传值：简单数据类型，传递数值，开辟新地址
传址：复杂数据类型，传递地址，共享同一个内存空间

浅拷贝：只拷贝数值，不拷贝地址，节省内存，但是因为共享内存，所以互相影响数据
深拷贝：数值和内存都拷贝，内存空间相互独立，不互相影响数据

深拷贝
方法一：
通过`JOSN.parse()`和`JOSN.stringify()`
将通过上述两种方法处理过后的对象赋值给新变量
方法二：

>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206185943827.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

#### []()操作符

1.`instanceof()` 判断一个实例对象，是否是某个函数的实例
语法:`对象名 instanceof 函数名`

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206190817680.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206190830245.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

2.isPrototypeOf() 判断该原型是否是该对象所属原型
语法：`原型名.isPrototypeOf(对象名)`

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206191208614.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206191217474.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

3.`hasOwnProperty()`用来检测当前对象中是否有该属性, 返回值为布尔类型
不会检查原型和原型链上的内容,只会去查找构造函数中的内容
语法：`对象名.hasOwnProperty("属性/方法名")`

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206193725967.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/2020020619373688.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

4.`delete`  用来删除属性
语法：`delete 属性`

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206195145354.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
>显示效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206195155675.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

5.`in` 检查该对象是否包含指定属性
检查范围包括对象的直接属性和prototype继承来的属性，不包括原型自身的属性/方法(原型重构，被覆盖)
语法：`属性/方法名 in 对象`

>代码：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/2020020619540926.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)显示 效果：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/2020020619540918.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)

## []()拖拽

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207125058911.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207125105676.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207125111652.png?x-oss-processimage/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCRl9fY2c,size_16,color_FFFFFF,t_70)
